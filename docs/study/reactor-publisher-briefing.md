# 리액터 퍼블리셔 핵심 브리핑

## Executive Summary
- 리액터(Reactor)는 Spring WebFlux의 공식 리액티브 라이브러리로, 리액티브 스트림즈 명세를 구현한 비동기 데이터 스트림 처리 프레임워크이다.
- 퍼블리셔(Publisher)의 역할을 직접 구현하지 않고도 `Mono`와 `Flux`를 사용해 데이터 흐름을 제어하는 **사용자 관점**으로 전환된다는 점이 핵심 경험이다.
- `Mono`는 0개 또는 1개의 요소만 발행하는 단일 결과용, `Flux`는 0개 이상 순차 요소를 다루는 범용 스트림으로 특화되어 있다.
- `Flux`는 데이터 생성 방식에 따라 **콜드 퍼블리셔**(구독할 때마다 정해진 시퀀스를 다시 발행)와 **핫 퍼블리셔**(독립적으로 지속 생성)로 나뉘며, 구독 시점과 관계없이 흐름을 정의할 수 있다.
- 리액터의 퍼블리셔는 단순히 데이터를 발행하는 역할을 넘어 Subscriber와의 상호작용까지 내포하므로, 개발자는 전체 데이터 흐름을 통제하는 사용자 시점을 가져야 한다.

---

## 1. 리액터 개요와 패러다임 변화
### 1.1 정의 및 특징
- 리액터는 피보탈(Pivotal)이 개발하고 있는 리액티브 스트림즈 기반의 비동기 데이터 처리 라이브러리다.
- Spring WebFlux에서 공식 지원하며, 백프레셔(Backpressure)를 포함한 명세를 준수한다.
- 개발자는 이전처럼 `Publisher`, `Subscriber`, `Subscription` 인터페이스를 직접 구현할 필요 없이 이미 구현되어 있는 `Mono`와 `Flux`를 조합하여 스트림을 구성한다.
- 이로 인해 비동기 및 스트림 로직을 보다 직관적으로 사용하고, 복잡도를 낮추며, 전체 데이터 흐름을 **사용자 관점**에서 제어할 수 있게 된다.

> "이제 이 리액터로 넘어오면서 그것들이 어느 정도 다 구현이 되어 있는 상태에서 우리는 사용하는 입장, 사용자의 입장으로 점점 넘어온다고 봐 주시면 될 거 같습니다."

## 2. 퍼블리셔 계층 구조
- 리액티브 스트림즈 명세의 `Publisher`는 최상위 표준 인터페이스다.
- 리액터는 해당 인터페이스를 구현한 `CorePublisher`를 두며, 실제 사용자는 `Mono`와 `Flux`를 다룬다.
- `Mono`와 `Flux`는 `CorePublisher`를 상속받아 각각의 역할에 맞게 특화된 API를 제공함으로써 개발자가 구체적인 구현을 알 필요 없이 스트림 조작에 집중할 수 있다.

## 3. 핵심 퍼블리셔: Mono와 Flux
### 3.1 Mono: 0 또는 1개의 요소
- 단일 값이나 완료 신호가 중요할 때 사용하는 퍼블리셔로, 값을 방출한 뒤 바로 완료한다.
- 주요 사용 예
  - `findById`처럼 결과가 하나거나 없을 때
  - 결과보다 작업 완료 여부에 집중할 때
- 대표 메소드
  | 메소드 | 설명 |
  | --- | --- |
  | `just` | 주어진 단일 값을 감싸 `Mono` 객체를 생성한다. |
  | `empty` | 값을 방출하지 않고 완료 신호만 전송하는 빈 `Mono` 생성 |
  | `error` | 오류 신호만 보내는 `Mono` 생성 |
  | `map` | 값을 변환해 새로운 `Mono`로 반환 |
  | `flatMap` | 값을 다른 퍼블리셔(`Mono` 또는 `Flux`)로 변환 |

### 3.2 Flux: 0개 이상의 요소
- 일반적인 데이터 스트림과 가장 가까운 형태로, 여러 값을 순차적으로 발행하며 `onComplete`를 통해 종료를 알린다.
- `onComplete`를 생략하면 이론상 무한 스트림도 가능하다.
- 대표 연산자
  | 메소드 | 설명 |
  | --- | --- |
  | `just` | 여러 값을 순차 발행하는 `Flux` 생성 |
  | `fromIterable` | `Iterable` 요소를 순차적으로 방출 |
  | `range` | 지정 범위 정수를 순차 발행 |
  | `concat` / `merge` | 두 `Flux` 스트림을 하나로 합침 |
  | `filter` | 조건을 만족하는 요소만 통과시킴 |

## 4. Flux의 동작 모델: 콜드 vs 핫
### 4.1 콜드 퍼블리셔
- 구독이 발생할 때마다 정해진 데이터 시퀀스를 처음부터 전송하고, 이후 `onComplete`를 호출하여 종료한다.
- 각 구독자는 독립적인 스트림을 받으며, 얼마나 많은 데이터를 가지고 있는지 구독 전에 알 수 있다.

> "콜드 퍼블리셔는 특정 값을 이미 정해두고 보내고, 다 보내고 나서 컴플리트하고 끝내는 퍼블리셔."

### 4.2 핫 퍼블리셔
- 구독 시점과 무관하게 데이터를 지속적으로 생성하며, 구독자는 구독 시작 이후에 발생하는 값을 받는다.
- `onComplete` 신호를 보내지 않으면 무한히 데이터를 방출할 수 있으며, 데이터 생산량을 정확히 알기 어렵다.

> "서브스크라이브 하게 되면 계속 내가 받고 있는 값들을 넘겨 주는 구조, 이게 핫 퍼블리셔."

## 5. 결론 및 실습 전망
- `Mono`와 `Flux`는 단순한 `Publisher` 구현체를 넘어, `Subscriber`와의 상호작용까지 포함하여 전체 데이터 흐름을 제어하는 사용자 관점을 요구한다.
- 실습에서는 `subscribe()`와 같은 메소드 호출을 통해 `Mono`/`Flux` 객체를 직접 제어하게 되며, 별도 `Publisher`/`Subscriber` 구현 없이 스트림을 구성할 수 있다.
- 따라서 개발자는 개별 컴포넌트를 구현하기보다는, 전체 스트림을 설계하고 필요한 시점에 구독/연산을 적용하는 방식으로 애플리케이션을 구성해야 한다.
