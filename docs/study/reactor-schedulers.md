# 리액터 스케줄러 및 스레드 관리 연산자 분석

## 0. 요약

- Reactor에서 **스케줄러(Scheduler)** 는 비동기 작업을 어떤 **스레드 / 스레드 풀**에서 실행할지 제어하는 핵심 요소이다.
- 작업 유형은 크게 두 가지로 나뉜다.
  - **I/O-bound**: 네트워크, DB, 파일 입출력처럼 **대기 시간이 긴 작업**
  - **CPU-bound**: 암호화, 인코딩, 복잡한 연산처럼 **CPU 계산 위주 작업**
- I/O-bound 작업에는 **동적·재사용 가능한 스레드 풀**인 `boundedElastic` 스케줄러가, CPU-bound 작업에는 **CPU 코어 수만큼 고정된 스레드 풀**을 사용하는 `parallel` 스케줄러가 적합하다.
- 리액티브 스트림에서 실행 컨텍스트를 제어하기 위해 두 연산자를 사용한다.
  - `subscribeOn`: **구독 시작 시점과 전체 업스트림**의 실행 스레드를 지정
  - `publishOn`: 연산자 위치 이후 **다운스트림 구간**의 실행 스레드를 전환
- 이 조합을 통해 데이터 파이프라인 각 단계의 실행 컨텍스트를 세밀하게 제어하고, 시스템 자원을 효율적으로 활용할 수 있다.

---

## 1. 리액터 스케줄러 개요

- Reactor의 스케줄러는 비동기 작업을 **특정 스레드 또는 스레드 풀**에 할당하기 위한 추상화이다.
- 스케줄러를 사용하면:
  - “이 작업은 별도 스레드에서 처리”
  - “이 구간은 CPU 코어에 맞춰 병렬 처리”
  - “이 I/O 작업은 탄력적인 스레드 풀에서 처리”
  와 같이 **실행 컨텍스트를 명시적으로 표현**할 수 있다.
- `Schedulers` 유틸리티 클래스를 통해 다양한 스케줄러를 생성한다.

---

## 2. 스케줄러 유형 및 주요 특징

아래는 Reactor가 제공하는 주요 스케줄러와 그 특징, 적합한 작업 유형이다.

### 2.1 `Schedulers.immediate()`

- **스레드 모델**: 현재 스레드
- 특징:
  - 별도의 스레드 전환 없이, **지금 실행 중인 스레드**에서 바로 작업을 수행.
  - 사실상 스케줄러를 사용하지 않는 것과 유사.
- 사용 사례:
  - 테스트나 디버깅 등에서 스레드 전환 없이 **동기적으로 흐름을 추적**하고 싶을 때.

### 2.2 `Schedulers.single()` / `Schedulers.newSingle(name)`

- **스레드 모델**: 단일 전용 스레드
- 특징:
  - 하나의 스레드에 모든 작업이 순차적으로 배치된다.
  - `newSingle(name)`은 같은 모델이지만, 스레드에 이름을 붙여 디버깅·로깅에 유리하다.
- 사용 사례:
  - 특정 작업을 **한 스레드에서만 처리**해야 할 때.
  - 간단한 스레드 분리, 직렬화가 필요한 작업.

### 2.3 `Schedulers.elastic()` (Deprecated)

- **스레드 모델**: 동적 스레드 풀 (이전 방식)
- 특징:
  - 필요에 따라 스레드를 생성·재사용하고, 오래 사용하지 않는 스레드는 자동 종료.
  - Java 9 이후로는 권장되지 않으며, 대신 `boundedElastic` 사용 권장.
- 사용 사례:
  - 과거에는 I/O-bound 작업에 널리 사용되었으나, 지금은 새로운 코드에서 지양.

### 2.4 `Schedulers.boundedElastic()`

- **스레드 모델**: 제한된 동적 스레드 풀
- 특징:
  - `elastic()`을 대체하는 스케줄러.
  - 생성 가능한 스레드 수에 **상한(기본: CPU 코어 수 × 10)** 을 두어, 무한정 늘어나지 않도록 제어.
  - 많은 수의 작업이 **대기 상태(I/O 대기)** 에 있을 수 있는 상황에 적합.
- 사용 사례 (I/O-bound)
  - HTTP API 호출 및 응답 대기
  - DB 쿼리 실행 및 결과 수신
  - 파일 읽기/쓰기

### 2.5 `Schedulers.newBoundedElastic(...)`

- **스레드 모델**: 세밀한 설정이 가능한 제한된 동적 스레드 풀
- 특징:
  - 최대 스레드 수, 큐에 쌓일 수 있는 작업 수(대기 작업 수), 스레드 이름 등을 직접 지정.
  - 대규모 I/O 작업 환경에서 자원 사용량을 **정책적으로 관리**할 때 유용.
- 사용 사례:
  - 트래픽 패턴과 자원 한계를 잘 알고 있고, 이를 바탕으로 **정교한 스레드 풀 튜닝**이 필요한 서비스.

### 2.6 `Schedulers.parallel()`

- **스레드 모델**: 고정 스레드 풀 (CPU 코어 수만큼)
- 특징:
  - 기본적으로 **CPU 코어 수와 동일한 개수**의 스레드를 생성.
  - 각 스레드는 CPU를 최대한 활용하는 방향으로 병렬 작업을 처리.
- 사용 사례 (CPU-bound)
  - 암호화/복호화
  - 이미지/동영상 인코딩
  - 복잡한 수학 연산, 머신러닝 연산 등

### 2.7 `Schedulers.fromExecutorService(...)`

- **스레드 모델**: 사용자 정의 스레드 풀 기반
- 특징:
  - 기존의 `ExecutorService`를 감싸서 **커스텀 스케줄러**를 만들 수 있다.
  - 이미 운영 중인 스레드 풀과 Reactor를 통합해야 할 때 유용.
- 사용 사례:
  - 레거시 코드나 다른 프레임워크에서 관리하는 스레드 풀을 그대로 활용하고 싶은 경우.

---

## 3. I/O-bound vs. CPU-bound 작업

스케줄러를 잘 선택하려면 **“내가 처리하려는 작업이 무엇 중심인가?”** 를 먼저 구분해야 한다.

### 3.1 I/O-bound 작업 (입출력 중심)

- 정의:
  - CPU 연산보다 **외부 장치(네트워크, 파일, DB)** 와의 입출력 대기에 대부분의 시간이 쓰이는 작업.
- 특징:
  - CPU는 대기 시간이 길어 상대적으로 할 일이 적다.
  - 동시 요청이 많더라도, 각 스레드는 대부분 “기다리는 상태”에 가까움.
- 예시:
  - 외부 HTTP API 호출 및 응답 대기
  - 데이터베이스 쿼리 실행 및 결과 수신
  - 파일 시스템 읽기/쓰기
- 스케줄링 전략:
  - 하나의 스레드가 I/O 대기 중일 때, 다른 스레드가 다른 작업을 처리할 수 있도록 **여러 스레드를 운용**하는 것이 유리.
  - `boundedElastic`(또는 튜닝된 `newBoundedElastic`) 스케줄러가 대표적인 선택.

### 3.2 CPU-bound 작업 (연산 중심)

- 정의:
  - 대부분의 시간이 CPU 계산에 쓰이는 작업으로, **입출력 대기 시간이 거의 없음**.
- 특징:
  - CPU 사용률이 높으며, 작업을 더 빨리 하려면 **CPU 코어를 최대한 병렬 활용**해야 한다.
  - 스레드 개수가 CPU 코어 수보다 너무 많아지면, **컨텍스트 스위칭 오버헤드** 때문에 오히려 느려질 수 있다.
- 예시:
  - 암호화/복호화 연산
  - 동영상 인코딩, 이미지 처리
  - 머신러닝 학습, 복잡한 수학 연산
- 스케줄링 전략:
  - CPU 코어 수와 비슷한 개수의 스레드를 사용하여 오버헤드를 최소화.
  - Reactor에서는 `parallel` 스케줄러가 이런 용도에 맞게 설계되어 있다.

---

## 4. 스레드 제어를 위한 주요 연산자

스케줄러 자체는 “스레드 풀”이고, 이를 **리액티브 스트림에 적용**하는 역할을 하는 것이 `subscribeOn`, `publishOn` 두 연산자이다.

### 4.1 `subscribeOn` – 구독 시작 시점의 스레드를 지정

- 역할:
  - **구독이 시작되는 시점**의 실행 스레드를 지정한다.
  - 데이터 소스를 포함한 **전체 업스트림(upstream)** 에 영향을 미친다.
- 특징:
  - 연산자 체인 어디에 위치하든, **소스가 실행되는 스레드를 결정**한다.
  - 예:
    - `Flux.range(1, 5).map(...).subscribeOn(Schedulers.boundedElastic())`
    - 위 코드에서 `range(1, 5)`로 숫자를 생성하는 부분부터, 그 위의 연산까지 모두 `boundedElastic` 스레드에서 시작된다.

### 4.2 `publishOn` – 스트림 중간에서 스레드를 전환

- 역할:
  - 연산자가 위치한 지점 이후의 **다운스트림(downstream)** 작업을 다른 스레드로 전환한다.
- 특징:
  - `publishOn` 이후에 오는 연산들만 해당 스케줄러에서 실행된다.
  - 연산자의 **위치가 매우 중요**하다.
  - 예:
    - `source.map(...).publishOn(Schedulers.parallel()).map(...).filter(...)`
    - 첫 번째 `map`은 기존 스레드에서 실행되지만,
    - `publishOn` 이후의 두 번째 `map`, `filter`는 `parallel` 스케줄러의 스레드에서 실행된다.

---

## 5. 실용적 고려사항 및 결론

### 5.1 테스트·예제 코드에서의 주의점

- 비동기 코드는 **메인 스레드가 먼저 종료**되면 결과를 보기 전에 프로그램이 끝나버릴 수 있다.
- 예제나 간단한 테스트에서는:
  - `Thread.sleep(...)` 등으로 메인 스레드를 잠깐 대기시켜
  - 비동기 작업이 완료될 시간을 확보하는 경우가 있다.
- 실제 애플리케이션에서는:
  - 웹 서버(Netty 등)가 이벤트 루프를 유지하므로, 일반적으로 이런 문제가 발생하지 않는다.

### 5.2 정리

- Reactor의 스케줄러는 **“어떤 작업을 어떤 스레드에서 돌릴 것인가”** 를 결정하는 중요한 도구이다.
- I/O-bound 작업에는 `boundedElastic`, CPU-bound 작업에는 `parallel`을 사용하는 것이 기본 원칙이다.
- `subscribeOn`과 `publishOn`을 적절히 조합하면:
  - 데이터 소스의 실행 위치,
  - 특정 처리 단계의 실행 스레드
  를 명확히 분리·제어할 수 있다.
- 작업 특성을 먼저 파악한 뒤 **알맞은 스케줄러를 선택**하는 습관을 들이면,
  - WebFlux/Reactive 기반 애플리케이션에서 **자원 효율성과 반응성**을 동시에 끌어올릴 수 있다.

