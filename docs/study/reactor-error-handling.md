# Reactor 예외 처리: 주요 개념 및 연산자 분석

## 0. 요약

- Reactor 스트림(Mono / Flux)에서 예외가 발생하면 기본 동작은
  - 스트림 즉시 종료 →
  - `onError` 신호 전파 →
  - 이후 데이터 처리 중단 →
  - `onComplete` 미호출
  이다.
- 이 기본 동작을 제어·변형하기 위해 다양한 예외 처리 연산자를 제공한다.
  - `onErrorReturn`: 에러 발생 시 **정적 기본값**으로 대체 후 종료
  - `onErrorResume`: 에러 발생 시 **대체 시퀀스(Fallback Publisher)** 로 이어가기
  - `onErrorContinue`: 에러를 유발한 데이터만 건너뛰고 **다음 데이터 처리 계속**
  - `onErrorMap`: 기존 예외를 **다른 예외로 변환**하여 전파
  - `onErrorStop`: 에러 발생 시 **즉시 모든 처리 중단**
  - `retry`: 에러 발생 시 **지정 횟수만큼 스트림 재시도**
- 전역 범위에서 에러를 처리하는 **글로벌 에러 핸들링(Hooks)** 도 존재하며, Spring MVC의 `@RestControllerAdvice` 와 유사한 역할을 한다.

---

## 1. Reactor의 기본 에러 처리 흐름

Reactor 스트림 내에서 작업 수행 중 예외가 발생하면, 흐름은 다음과 같다.

1. **예외 캡처 및 스트림 종료**
   - Reactor는 발생한 예외를 캡처하고 즉시 해당 스트림을 종료한다.

2. **메시지 발행 중단**
   - 스트림이 에러로 종료되면 이후에는 **더 이상의 데이터(onNext) 발행이 없다**.

3. **후속 처리 단계 미진행**
   - 에러 이후에 정의된 `map`, `filter` 등 연산자는 **실행되지 않는다**.

4. **에러 신호 전파 (`onError`)**
   - 발생한 에러는 스트림의 처리 단계를 따라 Subscriber에게 `onError` 신호로 전달된다.

5. **구독자의 에러 수신**
   - 구독자는 `onError` 메서드를 통해 에러를 수신하고 정의된 로직(로깅, 재시도 요청 등)을 수행한다.
   - 예: `subscribe(onNext, onError, onComplete)` 형태에서 두 번째 인자 람다가 실행된다.

6. **비정상 완료 (onComplete 미호출)**
   - 에러가 발생한 스트림은 **정상 완료(onComplete)** 를 호출하지 않는다.
   - 대신 에러 경로로 진입해 `onError` 호출 후 스트림이 종료된다.

---

## 2. 에러 처리 연산자(Operator) 분석

기본 에러 흐름을 커스터마이징하기 위해 Reactor는 여러 연산자를 제공한다.

### 2.1 `onErrorReturn` – 정적 기본값으로 대체

- 목적:
  - 에러 발생 시 **미리 정의된 하나의 기본값**으로 대체하고 스트림을 종료.
- 동작 방식:
  - 처리 도중 에러가 발생하면 해당 에러를 가로채, 지정된 기본값을 **단 한 번 방출**한 뒤 스트림을 정상 종료(onComplete)한다.
- 예시 시나리오:
  - `Flux.just(1, 2, 0, 3)` 에서 각 숫자로 `10 / n` 연산을 수행.
  - `n = 0`일 때 예외 발생.
  - `onErrorReturn(-1)` 사용 시, 결과: `10, 5, -1` 방출 후 종료.
  - 0 이후의 데이터(3)는 처리되지 않는다.

### 2.2 `onErrorResume` – 동적 대체 시퀀스로 이어가기

- 목적:
  - 에러를 대체할 **새로운 Publisher(대체 스트림)** 를 동적으로 생성하여 이어간다.
- 동작 방식:
  - 에러가 발생하면, `onErrorResume`에 전달된 함수가 호출된다.
  - 이 함수는 에러 객체를 인자로 받아, 새로운 `Mono` 또는 `Flux` 를 반환한다.
  - 이후 구독자는 이 새 스트림이 방출하는 데이터를 계속해서 수신한다.
- 예시 시나리오:
  - 위와 동일한 0 나누기 예제에서,
  - `onErrorResume(e -> Flux.just(-4, -5))` 를 사용하면
  - 결과: `10, 5` 후에 `-4, -5` 가 이어서 방출된다.

### 2.3 `onErrorContinue` – 문제를 일으킨 데이터만 건너뛰기

- 목적:
  - 에러가 발생하더라도 스트림 전체를 종료하지 않고,
  - **에러를 유발한 요소만 건너뛰고 나머지 요소 처리를 계속**한다.
- 동작 방식:
  - `(Throwable error, Object value)` 를 인자로 받는 `BiConsumer` 를 사용한다.
  - 여기서 `value` 는 에러를 일으킨 원본 데이터이며, 이 시점에 로깅 등 부가 작업을 수행할 수 있다.
  - 해당 요소에 대한 처리는 건너뛰고, 다음 요소로 넘어간다.
- 예시 시나리오:
  - `Flux.just(1, 2, 0, 3)` 에서 0에서 예외 발생.
  - `onErrorContinue(...)` 사용 시, 0에 대한 결과는 스킵하고 1, 2, 3에 대한 처리 결과만 최종 방출.

### 2.4 `onErrorMap` – 예외 타입 변환

- 목적:
  - 기존 예외를 **다른 예외(커스텀 예외 등)** 로 변환해 전파.
  - 서비스/도메인에 맞는 **일관된 예외 계층**을 만들 때 유용하다.
- 동작 방식:
  - `Throwable` 을 입력으로 받아 새로운 `Throwable` 을 반환하는 함수 적용.
  - 예: `onErrorMap(original -> new MyCustomException(..., original))`
- 사용 사례:
  - 여러 곳에서 발생하는 공통 예외를 **도메인 전용 예외**로 감싸고 싶을 때.
  - 단순히 다른 유형의 에러로 바꾸기만 한다면 `onErrorResume` 대신 `onErrorMap` 이 더 간결하다.

### 2.5 `onErrorStop` – 더 이상의 처리 방지

- 목적:
  - 에러 발생 시점에서 **즉시 스트림 처리를 완전히 중단**하고,
  - 이후에 정의된 다른 에러 처리 로직(예: `retry`) 등의 적용을 막는다.
- 동작 방식:
  - 특별한 파라미터 없이 체인에 추가.
  - Reactor의 기본 동작(에러 → 스트림 종료)과 비슷하지만,
  - **다운스트림에서 추가적인 에러 처리 시도 자체를 차단**하는 데 의미가 있다.

### 2.6 `retry` – 스트림 재시도

- 목적:
  - 에러 발생 시 스트림을 **지정된 횟수만큼 처음부터 재구독(re-subscribe)** 한다.
- 동작 방식:
  - 에러 신호를 받으면 현재 구독을 취소하고, 소스 Publisher에 대해 다시 `subscribe` 를 호출.
  - 일시적인 네트워크 장애, 타임아웃 등 **일시적 오류**에 대응할 때 유용.
- 중요한 주의사항:
  - 스트림이 **처음부터 다시 실행**되므로, 이미 처리된 데이터가 **중복 처리**될 수 있다.
  - 예: `1, 2, 0, 3` 에서 0에서 에러 발생 후 `retry(1)`:
    - 재시도 시 다시 `1, 2, 0, 3` 이 반복되므로, 1과 2는 두 번 처리될 수 있다.
  - 따라서
    - 중복 처리가 허용되는 경우에만 사용하거나,
    - 중복을 감안한 보정 로직(중복 체크, idempotent 설계 등)을 반드시 고려해야 한다.

---

## 3. 글로벌 에러 핸들링 (Global Error Handling)

- Reactor에는 **애플리케이션 전역에서 일괄적으로 에러를 처리**하는 기능이 존재한다.
- 핵심 개념:
  - `Hooks` 를 활용해 전역 에러 처리 전략을 등록할 수 있다.
  - Spring MVC의 `@RestControllerAdvice` 와 유사하게, 여러 스트림에 공통으로 적용되는 **글로벌 에러 정책**을 정의하는 용도.
- 예시 아이디어:
  - `onErrorDropped`, `onErrorResume` 등의 훅을 통해
    - 로깅 공통화,
    - 특정 예외 유형에 대한 공통 대응 방식 설정
  - 본 소스 컨텍스트에서는 **개념만 언급**되었고, 구체적 사용법은 심층 설명하지 않았다.

---

## 4. 개발자 관점에서의 고려사항

- **처음에는 복잡하게 느껴짐**
  - 메서드 체인 안에서 비동기적으로 흘러가는 스트림에 대해 에러를 처리하는 방식은,
  - 전통적인 동기/명령형 예외 처리(`try-catch`)에 익숙한 개발자에게 직관적이지 않을 수 있다.

- **익숙해지면 일반적인 예외 처리처럼 사용 가능**
  - 각 연산자의 역할과 흐름을 이해하고 나면,
  - “이 지점에서 에러가 나면 어떻게 처리할지” 를 선언적으로 표현하는 것에 익숙해지게 된다.
  - 결국에는 동기 코드의 `try-catch` 와 비슷한 감각으로 **스트림의 에러 흐름을 구성**할 수 있다.

---

## 5. 정리

- Reactor 스트림의 기본 에러 처리:
  - 에러 발생 → 스트림 즉시 종료 → `onError` 전파 → `onComplete` 미호출.
- 이를 기반으로 다양한 연산자를 조합하여,
  - **기본값으로 대체**(onErrorReturn),
  - **대체 시퀀스로 이어가기**(onErrorResume),
  - **문제 요소만 건너뛰기**(onErrorContinue),
  - **예외 유형 변환**(onErrorMap),
  - **즉시 중단**(onErrorStop),
  - **재시도**(retry)
  등의 전략을 설계할 수 있다.
- 글로벌 에러 핸들링(Hooks)까지 함께 이해하면,
  - 개별 스트림 수준부터 애플리케이션 전반에 이르기까지
  - **일관된 예외 처리 정책**을 구축할 수 있다.
- 초기에 약간의 학습 곡선은 존재하지만,
  - 연산자들의 역할을 명확히 구분해 연습하다 보면
  - Reactor 예외 처리 역시 다른 예외 처리 기법처럼 자연스럽게 사용할 수 있게 된다.

