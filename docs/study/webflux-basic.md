# Spring WebFlux 기초 정리

## 1. WebFlux 정의

- Spring 5에서 도입된 **비동기·논블로킹(Non-blocking)** 웹 프레임워크
- 기존 Spring MVC(Servlet 기반)와 달리 **Reactive Streams** 사양을 기반으로 동작
- **Netty, Undertow, Servlet 3.1+ 컨테이너** 등 논블로킹 서버 위에서 실행 가능
- `Mono`, `Flux` 등의 리액티브 타입을 사용해 **데이터 흐름 중심의 선언적 코드**를 작성

정리하면, WebFlux는 “적은 자원으로 많은 동시 요청을 처리하기 위해 설계된, 리액티브 프로그래밍 기반의 웹 프레임워크”이다.

## 2. WebFlux의 특징

- **논블로킹 I/O**
  - 요청/응답을 처리할 때 스레드가 I/O 작업(디스크, 네트워크 등)을 기다리며 블로킹되지 않음
  - 한 개의 스레드가 여러 요청을 효율적으로 처리 가능

- **리액티브 타입 사용 (Mono / Flux)**
  - `Mono<T>`: 0~1개의 요소를 비동기로 처리
  - `Flux<T>`: 0~N개의 요소(스트림)를 비동기로 처리
  - 데이터가 “언제 준비되는지”가 아니라 “준비되었을 때 어떻게 처리할지”를 선언적으로 표현

- **함수형·선언적 스타일**
  - `flatMap`, `map`, `filter` 등 연산자를 통해 파이프라인을 구성
  - `RouterFunction`, `HandlerFunction`을 사용한 함수형 라우팅도 제공

- **Backpressure 지원**
  - 구독자(consumer)가 생산자(producer)에 데이터 처리 속도를 조절해 달라고 요청할 수 있음
  - 과도한 데이터로 인해 소비자가 압도되지 않도록 제어하는 메커니즘

- **가벼운 스레드 사용**
  - 블로킹 방식처럼 요청당 스레드를 하나씩 고정으로 점유하지 않음
  - 고성능·고동시성 환경에서 스레드 컨텍스트 스위칭 비용이 줄어듦

## 3. WebFlux가 필요한 이유

1. **높은 동시성 처리**
   - 대량의 클라이언트 요청(예: 수천~수만)을 상대적으로 적은 자원으로 처리하고 싶을 때
   - 기존 블로킹 MVC는 연결 수에 비례해 스레드가 늘어나면서 한계가 빨리 도달

2. **I/O 중심 애플리케이션**
   - 내부적으로 DB, 외부 API, 메시지 브로커 등 느린 I/O에 자주 접근하는 애플리케이션
   - 실제 CPU 계산보다 **대기 시간(latency)** 이 큰 경우에 특히 효과적

3. **스트리밍·실시간 처리**
   - SSE(Server-Sent Events), WebSocket, 데이터 스트리밍 등 “끊기지 않는 연결”이 중요한 경우
   - 반응형 스트림 기반이라 연속 데이터 처리에 자연스럽게 어울림

4. **리액티브 아키텍처 도입**
   - 시스템 전체를 리액티브하게 설계(메시지 지향, 탄력성, 회복력 등)하고자 할 때
   - 마이크로서비스들 간에 리액티브 통신을 구성하는 기반이 됨

## 4. WebFlux를 언제 사용하면 좋은가?

- 다음과 같은 조건일 때 WebFlux를 고려하는 것이 적절하다.

1. **동시 접속자가 매우 많고, 요청당 작업이 I/O 위주**일 때
   - 예: 여러 외부 API 호출을 조합하는 API Gateway, BFF(Backend for Frontend)

2. **스트리밍, 실시간 업데이트가 중요할 때**
   - 예: 실시간 알림 서비스, 채팅, 주식/코인 시세 스트리밍, 로그/메트릭 스트리밍

3. **이미 리액티브 스택을 사용 중일 때**
   - 예: R2DBC, Reactive MongoDB, Reactive Redis, Kafka 등 리액티브 클라이언트와 연계

4. **리액티브 프로그래밍 학습/도입이 목표인 경우**
   - WebFlux 기반 프로젝트를 통해 리액티브 개념과 패턴을 자연스럽게 습득 가능

반대로, 단순한 CRUD 위주의 소규모 서비스나, 팀 전체가 동기 MVC에 익숙하고 리액티브에 대한 학습 여력이 부족할 경우에는 굳이 WebFlux를 사용할 필요는 없다.

## 5. 기존 Spring MVC와의 차이점

### 5.1 프로그래밍 모델

- Spring MVC
  - `@Controller`, `@RestController`, `@RequestMapping` 기반의 **어노테이션 스타일**
  - 리턴 타입: `String`, `ModelAndView`, `ResponseEntity<T>`, `T` 등 **동기 타입** 위주
  - 내부적으로 **Servlet API**(블로킹) 기반

- Spring WebFlux
  - 동일하게 `@RestController` 등을 사용할 수 있지만, 리턴 타입이 `Mono<T>`, `Flux<T>`
  - 또는 `RouterFunction`, `HandlerFunction`을 사용하는 **함수형 라우팅** 모델도 제공
  - 내부적으로 **Reactive Streams** + 논블로킹 서버(Netty 등)

### 5.2 실행 기반(서버, 스레드 모델)

- Spring MVC
  - 기본적으로 **Tomcat, Jetty 등 Servlet 컨테이너** 기반
  - 요청당 스레드 1개를 매핑하는 **Thread-per-request** 모델
  - 블로킹 I/O를 전제로 설계

- Spring WebFlux
  - 기본 서버: **Netty** (또는 논블로킹 Servlet 컨테이너)
  - **이벤트 루프 기반**으로 적은 스레드로 많은 요청을 처리
  - 논블로킹 I/O를 전제로 설계

### 5.3 성능 특성

- Spring MVC
  - 적당한 동시성(예: 수백~수천)에서는 이해하기 쉽고 안정적
  - 하지만 동시 접속자가 폭발적으로 늘면 스레드 수 증가 → 컨텍스트 스위칭 비용 증가 → 성능 저하

- Spring WebFlux
  - 높은 동시성 환경 + I/O 중심 작업에서 **리소스 효율성**이 뛰어남
  - 코드와 디버깅 난이도가 더 높을 수 있고, 팀이 리액티브에 익숙해야 진가 발휘

### 5.4 생태계·라이브러리

- Spring MVC
  - 오랜 시간 축적된 라이브러리, 예제, 문서가 매우 풍부
  - JPA/Hibernate 등 동기 블로킹 라이브러리와 자연스럽게 연동

- Spring WebFlux
  - R2DBC, Reactive MongoDB 등 **리액티브 전용 라이브러리**를 사용해야 진정한 논블로킹 구조 가능
  - 일부 라이브러리는 여전히 동기 방식만 지원 → 중간에 블로킹 코드가 섞이면 이점이 줄어듦

## 6. WebFlux를 사용할 때 유의할 점

- **블로킹 호출을 최대한 제거**해야 한다.
  - 리액티브 체인 안에서 동기 JDBC, RestTemplate 같은 블로킹 코드를 사용하면 병목 발생
  - 가능하면 `WebClient`, R2DBC, 리액티브 클라이언트 등 논블로킹 라이브러리 사용

- **디버깅과 로깅이 MVC보다 복잡**할 수 있다.
  - 체인 중간 어디에서 에러가 나는지 파악하기 어렵거나, 콜스택이 직관적이지 않을 수 있음
  - `log()`, `doOnNext`, `checkpoint()` 등을 활용해 흐름을 추적

- **리액티브 사고 방식이 필요**
  - “먼저 이걸 하고, 그 다음에 저걸 한다”는 순차적 사고가 아닌
  - “데이터가 오면 이렇게 처리하고, 에러가 나면 저렇게 처리한다”는 이벤트 기반 사고가 필요

## 7. 정리

- WebFlux는 **리액티브 프로그래밍**과 **논블로킹 I/O** 기반의 웹 프레임워크이다.
- 높은 동시성, I/O 중심, 스트리밍/실시간 서비스에 특히 강점을 가진다.
- 기존 MVC와 비교했을 때 **서버 모델, 프로그래밍 모델, 사용 라이브러리**가 크게 다르다.
- 제대로 된 이점을 얻으려면 **전체 스택을 가능하면 리액티브하게 설계**해야 한다.
- 학습용으로는 WebFlux 프로젝트를 직접 만들어 보면서 `Mono`, `Flux`, 라우팅, WebClient 등을 하나씩 익히는 것이 가장 좋다.

> 앞으로 이 문서(`docs/study/webflux-basic.md`)를 기반으로,
> 예제 코드, 연습 문제, 실험 결과 등을 이어서 정리해 나가면 WebFlux 이해에 큰 도움이 될 것이다.

