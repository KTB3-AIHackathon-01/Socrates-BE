# 스프링 WebFlux 개요 및 심층 분석

## 0. 요약

- Spring WebFlux는 **비동기·논블로킹(Non-Blocking)** 통신과 **리액티브 스트림(Reactive Streams)** 을 기반으로 한 리액티브 웹 프레임워크이다.
- 핵심 특징은
  1) 스레드를 블로킹하지 않는 동작 방식,
  2) 함수형 엔드포인트(Functional Endpoints) 지원,
  3) 백프레셔(Backpressure)를 포함한 리액티브 스트림 사양 구현
  이다.
- 기존 Spring MVC의 명령형(Imperative)·블로킹 모델과는 사고방식이 크게 다르며, 리액티브 프로그래밍에 대한 이해 없이 도입하면 **성능 이점을 살리지 못하고 오히려 성능 저하**를 가져올 수 있다.

---

## 1. WebFlux 정의와 핵심 특징

### 1.1 정의

- Spring WebFlux는 Spring Framework 5.0부터 도입된 **리액티브 프로그래밍 모델 기반의 웹 프레임워크**이다.
- 기존 **서블릿 기반 Spring MVC와는 별도의 스택**으로, 논블로킹 I/O와 비동기 데이터 스트림을 중심으로 고성능·고확장성 애플리케이션을 목표로 한다.
- 구현체로는 **Project Reactor**(Mono, Flux)가 사용되며, 이는 리액티브 스트림 표준 사양의 대표적인 구현체이다.

### 1.2 비동기·논블로킹 통신

- 목표: **시스템 리소스를 최대한 효율적으로 사용**하는 것.
- 동기/블로킹 방식의 한계
  - 메서드 호출 후 결과가 반환될 때까지 스레드가 블로킹 상태로 대기한다.
  - 이 동안 스레드는 다른 일을 하지 못하고 “놀고 있는” 상태가 되어, 동시 요청이 많을수록 스레드가 급격히 늘어나고 리소스 낭비가 커진다.
- WebFlux의 접근
  - I/O 작업(네트워크, DB 등)의 완료를 기다리며 블로킹하지 않고, **요청을 비동기적으로 처리**한다.
  - 하나의 스레드가 여러 요청을 조금씩 나누어 처리하면서, **적은 수의 스레드로 많은 요청을 처리**할 수 있다.

### 1.3 함수형 엔드포인트(Functional Endpoints)

- 기존 방식: `@Controller`, `@RestController`, `@GetMapping` 등의 애너테이션 기반 컨트롤러.
- WebFlux 추가 기능: **함수형 라우팅 API** 를 통해 라우트(경로)와 핸들러를 **함수형 스타일**로 정의할 수 있다.
  - `RouterFunction` 빈을 정의하여 “어떤 path를 어떤 handler가 처리하는지”를 람다/메서드 참조로 명시.
  - Java 8의 람다 표현식과 메서드 참조를 적극적으로 활용.
- 장점
  - 라우팅 규칙이 코드상에서 **하나의 함수형 DSL처럼 보이므로 간결하고 읽기 쉬움**.
  - 라우팅 정의와 실제 비즈니스 핸들러를 분리할 수 있어 구조화가 수월하다.

### 1.4 리액티브 스트림(Reactive Streams)과 Project Reactor

- 리액티브 스트림은 **비동기 데이터 스트림을 논블로킹 백프레셔와 함께 처리하기 위한 표준 사양**이다.
- WebFlux는 이 사양의 구현체 중 하나인 **Project Reactor**를 기반으로 동작한다.
  - `Publisher`: 데이터 생산자
  - `Subscriber`: 데이터 소비자
  - `Subscription`: 둘 사이의 구독 관계 및 요청량 관리
- Reactor에서 `Mono<T>`(0~1개), `Flux<T>`(0~N개) 타입이 이러한 개념을 구현한 대표적인 타입이다.

---

## 2. 리액티브 프로그래밍 모델

### 2.1 전통적 명령형 vs 리액티브 모델

- 명령형(Imperative) 프로그래밍
  - “이 메서드를 호출하고 → 결과를 기다린 다음 → 다음 코드를 실행”하는 **순차적인 흐름**.
  - 일반적인 Spring MVC + 블로킹 I/O 환경에서 자연스럽게 사용하는 방식.

- 리액티브(Reactive) 프로그래밍
  - **데이터의 흐름(Flow)과 변화(Changes)** 를 중심으로 하는 비동기 패러다임.
  - 데이터가 발생하면 시스템이 그에 **“반응”** 하도록 설계한다.
  - 메시지 기반(Message-driven) 구조에 가깝고, 특정 스레드가 작업을 마치면 다른 스레드가 이어받아 처리하는 식으로 동작한다.
  - “언제 결과가 오는지”를 기다리는 것이 아니라, “결과가 왔을 때 어떻게 처리할지를 미리 선언”해 두는 방식이다.

### 2.2 구성 요소: Publisher / Subscriber / Subscription

- Publisher
  - 데이터 스트림을 생성하는 **생산자**.
  - 예: 1~100까지 숫자를 한 번에 리스트로 반환하는 대신, 1, 2, 3… 을 차례로 보내는 스트림을 만든다.

- Subscriber
  - Publisher가 발행하는 데이터를 **구독**하는 **소비자**.
  - `map`, `filter` 등의 연산자를 이용해 데이터를 가공·처리한다.

- Subscription
  - Publisher와 Subscriber 사이의 **연결 정보**.
  - Subscriber는 Subscription을 통해 **“한 번에 몇 개의 데이터를 받을 것인지”** 를 Publisher에게 요청한다.

---

## 3. 백프레셔(Backpressure)의 의미와 전략

### 3.1 백프레셔란?

- 정의: Subscriber가 처리할 수 있는 속도보다 Publisher가 데이터를 더 빠르게 밀어 넣는 상황에서, **데이터 흐름의 속도를 조절하여 과부하를 방지하는 메커니즘**.
- 비유: 수도꼭지의 물줄기 세기를 조절하듯, **데이터 공급 속도를 제어**하는 역할.
- 목적: 소비자가 처리 불가능한 양의 데이터를 받지 않도록 하여, **시스템 전체의 안정성**을 유지하는 것.

### 3.2 주요 전략

1. 속도 조절
   - Subscriber가 Subscription을 통해 “얼마나 많은 데이터를 받을 수 있는지” 요청하면, Publisher가 그 양만큼만 데이터를 보낸다.
   - 이상적인 백프레셔 처리 방식.

2. 데이터 폐기(Drop)
   - Publisher가 속도를 줄이기 어렵다면, **넘치는 데이터를 버리는 방식**을 사용할 수 있다.
   - Reactor 예: `onBackpressureDrop`.

3. 버퍼링(Buffer)
   - 당장 처리하지 못하는 데이터를 버퍼에 잠시 저장했다가, Subscriber가 처리 가능할 때 전달.
   - 버퍼가 너무 커지면 메모리 사용량이 급격히 증가할 수 있으므로 주의가 필요하다.

### 3.3 방어 로직의 필요성

- 특히 Drop 전략을 사용할 때는, **어떤 데이터가 유실될 수 있는지**를 Subscriber 측에서 인지해야 한다.
- 필요하다면 재전송 요청이나, 유실 허용 범위에 대한 정책 등을 설계하여 **비즈니스 차원의 방어 로직**을 구현해야 한다.

---

## 4. WebFlux 도입 시 고려사항

### 4.1 패러다임 전환과 학습 곡선

- WebFlux는 “기존에 사용하던 개념을 어느 정도 내려놓아야 한다”고 할 만큼 **사고방식의 전환**을 요구한다.
- 대표적인 어려움
  - 코드가 콜백/체인 형태로 흘러가므로, **흐름을 머릿속으로 따라가기 어려울 수 있음**.
  - 디버깅 시 콜스택이 명령형 코드만큼 직관적이지 않다.

### 4.2 블로킹 코드 혼용의 위험

- WebFlux 환경에서 실수로 동기식/블로킹 코드를 사용하면:
  - 애플리케이션이 “겉으로는 잘 동작”하지만, **비동기·논블로킹의 이점을 거의 얻지 못함**.
  - 특정 지점에서 스레드가 블로킹되며 **병목(bottleneck)** 이 발생해, MVC보다 더 나쁜 성능을 보일 수도 있다.
- 이를 방지하기 위한 방법
  - 코드 내 블로킹 호출을 탐지하는 테스트/도구를 사용하는 등 **자동 검증 체계**를 도입.
  - 팀 차원에서 “어디까지 리액티브 스택을 사용할 것인지” 명확히 합의.

---

## 5. 권장 선행 학습 및 학습 경로

WebFlux를 효과적으로 이해하고 활용하기 위해 다음 개념을 먼저 익혀 두면 도움이 된다.

### 5.1 자바 스트림(Java Streams)

- 리액티브 스트림과 동일한 것은 아니지만, `map`, `filter`, `flatMap` 등의 **함수형 연산 체인에 익숙해지는 연습용으로 적합**하다.
- “데이터 컬렉션에 연산을 선언적으로 적용한다”는 감각을 미리 익힐 수 있다.

### 5.2 비동기 모델: Future, CompletableFuture

- 스레드가 결과를 기다리며 블로킹되지 않고, **콜백/완료 시점에 작업을 이어가는 패턴**에 익숙해질 수 있다.
- WebFlux의 `Mono`, `Flux`도 “나중에 값을 받는다”는 점에서 비슷한 사고를 요구한다.

### 5.3 옵저버 패턴(Observer Pattern)

- “어떤 이벤트가 발생하면, 그 이벤트를 구독하고 있던 객체들에게 알린다”는 구조는 **Publisher-Subscriber 모델과 자연스럽게 연결**된다.
- 이벤트 기반의 데이터 흐름과 상태 변화 전파에 대한 감각을 길러 준다.

### 5.4 루즈 커플링(Loose Coupling)

- WebFlux는 시스템을 느슨하게 결합된 컴포넌트들의 조합으로 설계하는 데 잘 맞는 모델이다.
- 컴포넌트 간 결합을 줄이고 메시지 기반으로 통신할수록, **리액티브 아키텍처의 장점(탄력성, 확장성, 장애 격리 등)** 을 살리기 쉽다.

---

## 6. 정리

- Spring WebFlux는 **비동기·논블로킹 통신 + 리액티브 스트림 + 백프레셔**를 핵심으로 하는 리액티브 웹 프레임워크이다.
- 함수형 엔드포인트를 포함해, 기존 MVC와는 다른 스타일의 프로그래밍 모델을 제공한다.
- 제대로 사용하면 **높은 동시성, 우수한 자원 효율, 뛰어난 확장성**을 얻을 수 있지만,
  - 리액티브 프로그래밍에 대한 이해 부족,
  - 블로킹 코드 혼용,
  - 잘못 설계된 백프레셔 전략
  등으로 인해 오히려 성능이 나빠질 수 있다.
- 따라서 WebFlux 도입 전/초기에는
  - 리액티브 프로그래밍 기본 개념,
  - Project Reactor의 `Mono`/`Flux` 연산자,
  - 비동기 모델과 옵저버 패턴
  을 충분히 학습하고, 작은 예제/프로젝트로 실험해 보며 개념을 체화하는 것이 중요하다.

