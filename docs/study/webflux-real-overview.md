# 스프링 WebFlux 개요: 핵심 인사이트 및 심화 분석

## 0. 요약

- Spring WebFlux는 Spring Framework 5부터 도입된 **리액티브 기반 논블로킹 웹 프레임워크**로, 기존 동기·블로킹 방식의 Spring MVC에 대한 **대안 웹 스택**이다.
- Netty와 같은 **비동기 웹 서버 + 이벤트 루프(Event Loop)** 아키텍처를 기반으로, **더 적은 스레드와 리소스로 높은 동시성**을 처리하는 것을 목표로 한다.
- Java 8 람다를 적극 활용한 **함수형 프로그래밍 스타일**과 **메서드 체이닝(연속 스타일 API)** 을 통해 선언적이고 유연한 코드 구성이 가능하다.
- 실시간 스트리밍, 채팅, IoT 센서, API 게이트웨이 등 **“데이터는 작지만 발생 빈도가 매우 높은”** 서비스에 특히 적합하지만,
  - 기존 MVC 코드 재작성 비용,
  - 비동기 코드 디버깅 난이도,
  - 연동 시스템 전체의 논블로킹 I/O 지원 여부
  를 반드시 함께 고려해야 한다.

---

## 1. 스프링 WebFlux의 탄생 배경

### 1.1 자원 효율성(리소스 효율) 극대화

- 기존 Spring MVC는 **서블릿 컨테이너 + 요청당 스레드(Thread-per-request)** 모델을 사용한다.
  - 예: Tomcat의 기본 최대 스레드 200개
  - 동시 접속자가 많아질수록 스레드 수가 증가하고, 문맥 전환(Context Switching) 비용과 메모리 사용량이 크게 늘어난다.
- WebFlux는 Netty 등 **비동기 웹 서버** 위에서 동작하며, **이벤트 루프 기반**으로 적은 수의 스레드가 많은 요청을 처리한다.
  - I/O 대기 동안 스레드가 놀지 않고 다른 작업을 처리할 수 있어, **제한된 하드웨어로도 높은 동시성**을 처리할 수 있다.

### 1.2 함수형 프로그래밍 패러다임 도입

- Java 8의 **람다 표현식**을 적극 활용한 함수형 스타일을 지원한다.
- 메서드 체이닝(연속 스타일, continuation-style API)을 통해
  - “어떻게” 처리할지 보다는
  - “무엇을” 할지 선언적으로 표현하는 코드 작성을 지향한다.
- WebFlux는 어노테이션 기반 컨트롤러 외에도 **Router Function** 기반의 **함수형 라우팅 모델**을 제공하여, 이 패러다임을 더 잘 살릴 수 있는 구조를 마련했다.

---

## 2. 핵심 개념 및 아키텍처

### 2.1 리액티브 프로그래밍 (Reactive Programming)

- 핵심 개념: **“변화에 반응(Reactive)”** 하는 프로그래밍 모델.
- 전통적 명령형(Imperative) 방식:
  - 개발자가 정해진 순서대로 메서드를 호출하고,
  - 결과를 기다리며 다음 로직을 수행한다.
- 리액티브 방식:
  - I/O 이벤트, 데이터 스트림의 **변화**에 따라 로직이 **반응**한다.
  - UI 프로그래밍에서 마우스/키보드 이벤트에 반응하듯,
  - 서버 측에서도 데이터/이벤트 스트림을 중심으로 처리 흐름을 구성한다.

### 2.2 논블로킹(Non-Blocking)과 백프레셔(Backpressure)

- 논블로킹 I/O
  - 하나의 작업이 완료될 때까지 **스레드가 해당 작업에 묶여 블로킹되지 않는다**.
  - I/O 대기 시간 동안 다른 요청을 처리함으로써, **동시성 처리 효율**을 높인다.

- 백프레셔(Backpressure)
  - 비동기 환경에서 **데이터 생산 속도와 소비 속도**를 맞추기 위한 메커니즘.
  - Publisher(생산자)가 Subscriber(소비자)의 처리 속도를 초과해 데이터를 밀어 넣지 않도록, **소비자가 처리 가능한 양만 요청**하는 방식으로 흐름을 제어한다.
  - 이를 통해 과부하 상황에서도 시스템 안정성을 확보할 수 있다.

### 2.3 이벤트 루프와 옵저버 패턴

- 이벤트 루프(Event Loop)
  - Netty와 같은 비동기 서버는 **이벤트 루프 기반**으로 동작한다.
  - 소수의 스레드가 요청 수락, I/O 이벤트 감지, 콜백 실행 등을 순환하면서 처리.

- 옵저버 패턴(Observer Pattern)
  - 내부적으로는 **Publisher / Subscriber / Subscription** 구조를 사용한다.
  - Publisher는 데이터/이벤트를 발행하고, Subscriber는 이를 구독하여 반응한다.
  - 이는 리액티브 스트림즈(Reactive Streams) 사양과 연결되며, WebFlux는 Project Reactor 기반으로 이 모델을 구현한다.

---

## 3. Spring MVC와 WebFlux 비교 분석

| 구분            | Spring MVC                                  | Spring WebFlux                                               |
|-----------------|---------------------------------------------|--------------------------------------------------------------|
| 동작 방식       | 블로킹(Blocking), 동기적                    | 논블로킹(Non-blocking), 비동기적                             |
| 스레드 모델     | 요청당 스레드 할당 (Thread-per-request)     | 이벤트 루프 기반, 적은 수의 스레드                          |
| 코드 추적 난이도| 한 스레드가 전체 로직 처리 → 추적 용이      | 여러 스레드/연산자가 참여 → 체인 추적이 상대적으로 복잡     |
| 리소스 활용     | 동시성 증가 시 스레드 급증 → 리소스 많이 사용| 적은 스레드로 높은 동시성 → 리소스 효율성 높음              |
| 주요 웹 서버    | Tomcat, Jetty, Undertow(서블릿 모드)        | Netty, Undertow 등 비동기 서버(서블릿 3.1+ 논블로킹도 가능) |

### 3.1 공통 기술 스택

- 두 스택은 완전히 분리된 세계가 아니다.
  - WebFlux에서도 `@Controller`, `@RestController` 같은 어노테이션 기반 컨트롤러를 사용할 수 있다.
  - MVC에서도 `WebClient` 같은 리액티브 HTTP 클라이언트를 사용할 수 있다.
  - Tomcat, Jetty, Undertow 등은 설정에 따라 **블로킹/논블로킹 모드**로 모두 활용 가능하다.

---

## 4. WebFlux의 주요 구성 요소

Spring WebFlux는 엔드포인트(HTTP API)를 정의하는 두 가지 스타일을 제공한다.

### 4.1 어노테이션 기반 컨트롤러

- `@RestController`, `@Controller` + `@GetMapping`, `@PostMapping` 등
- 기존 Spring MVC와 거의 동일한 프로그래밍 모델.
- 차이점:
  - 반환 타입으로 `Mono<T>`, `Flux<T>` 와 같은 리액티브 타입을 사용한다.
  - 내부 처리가 비동기·논블로킹 방식으로 이루어진다.
- 장점:
  - 기존 MVC 개발자에게 가장 친숙한 진입점.

### 4.2 라우터 함수 (Router Functions)

- 함수형 프로그래밍을 더 적극적으로 활용하는 모델.
- `RouterFunction` / `HandlerFunction` 기반으로,
  - 람다와 메서드 체이닝으로 라우팅 규칙을 선언적으로 구성한다.
- 예시 개념:
  - HTTP 메서드, 경로, 헤더, 콘텐츠 타입 등 다양한 Predicate를 조합해
  - “어떤 요청이 들어오면 어떤 핸들러가 처리할지” 를 함수형으로 표현.
- 장점:
  - 라우팅과 비즈니스 로직을 분리하고,
  - DSL처럼 읽히는 선언적 라우팅 구성이 가능하다.

---

## 5. 대표적인 사용 사례와 장점

### 5.1 적합한 서비스 유형

WebFlux는 **“대상 데이터는 작지만 이벤트 발생 빈도가 매우 높은”** 서비스에 특히 잘 맞는다.

- 실시간 채팅 서비스
  - 수많은 사용자가 동시에 메시지를 주고받는 환경.
- 실시간 스트리밍 데이터
  - 예: 주식/코인 시세, 거래 정보 등 지연을 최소화해야 하는 데이터.
- IoT 센서 데이터 처리
  - 수많은 센서에서 지속적으로 작은 데이터가 유입되는 경우.
- API 게이트웨이
  - 여러 백엔드 서비스를 호출·조합해 응답하는 관문 서비스.
  - 외부 클라이언트의 모든 요청이 집중되기 때문에 높은 동시성 처리 능력이 중요하다.

### 5.2 주요 장점

- 높은 동시성 처리 능력
  - 논블로킹 I/O를 활용하여 적은 수의 스레드로 많은 요청을 처리.
- 리소스 효율성
  - 기존 서블릿 모델보다 메모리·스레드 사용량이 적어,
  - 동일 하드웨어로 더 많은 트래픽을 처리할 수 있고 인프라 비용을 절감할 가능성이 있다.
- 빠른 응답 속도 (조건부)
  - 블로킹 대기 시간이 줄어드는 구조라,
  - 적절히 설계하면 특정 유형의 서비스에서 응답 지연을 줄일 수 있다.
  - 단, 전체 아키텍처·연동 시스템 설계에 따라 효과는 달라진다.

---

## 6. 도입 시 고려사항

WebFlux의 장점만 보고 무작정 도입하기보다는, 다음 사항을 신중히 검토해야 한다.

### 6.1 마이그레이션 및 코드 재작성 비용

- 기존 MVC 코드는 대체로 **동기·블로킹 + 명령형 스타일**로 작성되어 있다.
- WebFlux로 옮기려면:
  - 반환 타입을 `Mono`/`Flux` 로 바꾸고,
  - 내부 로직을 **리액티브 스트림 기반 메서드 체이닝**으로 재구성해야 하는 경우가 많다.
- 이는 단순한 프레임워크 교체가 아니라 **코드 패러다임 전환**에 가깝기 때문에 비용이 크다.

### 6.2 개발·디버깅 복잡성

- 비동기 호출 + 메서드 체인 + 스케줄러로 인한 스레드 전환 등으로,
  - “어떤 데이터가 어느 시점에 어느 스레드에서 처리되는지” 추적이 어렵다.
- 스택 트레이스도 동기 코드에 비해 직관적이지 않을 수 있어,
  - 로그·체크포인트·연습을 통한 디버깅 감각 향상이 필요하다.

### 6.3 연동 시스템의 논블로킹 I/O 지원 여부

- WebFlux의 장점을 **온전히 살리려면**:
  - DB, 캐시, 메시징 시스템, 외부 API 등 **모든 연동 지점이 논블로킹 I/O** 를 지원해야 한다.
- 만약 중간에 하나라도 동기/블로킹 컴포넌트가 있다면,
  - 해당 지점에서 결국 스레드가 블로킹되어 **전체 효율이 크게 떨어질 수 있다**.
- 따라서:
  - R2DBC, Reactive MongoDB, Reactive Redis, WebClient 등
  - 리액티브 스택 전체를 함께 고려한 도입 전략이 필요하다.

---

## 7. 결론: MVC vs WebFlux 선택 가이드

- 선택 기준의 핵심 질문:
  - **“내가 처리해야 할 메시지/트래픽의 특성은 무엇인가?”**

### 7.1 WebFlux를 고려할 때

- 높은 동시성과 리소스 효율성이 **절대적으로 중요한** 서비스:
  - 실시간 스트리밍, 대규모 채팅, IoT 허브, API 게이트웨이 등.
- 시스템 전반을 리액티브 스택으로 구성할 수 있거나, 그 방향으로 전환을 계획 중일 때.
- 팀이 리액티브 프로그래밍과 비동기 디버깅에 대한 학습 의지가 있고,
  - 패러다임 전환에 필요한 투자(시간, 인력)를 감당할 수 있을 때.

### 7.2 MVC를 유지/선택하는 것이 더 나을 때

- 트래픽 규모가 상대적으로 크지 않거나,
  - 일반적인 동시성 수준에서 MVC로도 충분히 대응 가능한 서비스.
- 개발 생산성과 생태계 호환성이 더 중요할 때:
  - 방대한 MVC 예제·라이브러리·문서,
  - 동기 코드의 직관적인 디버깅과 유지보수 편의성.
- 일부만 리액티브 클라이언트(WebClient 등)를 사용하고,
  - 전체 스택은 굳이 리액티브로 가져가지 않아도 되는 경우.

---

## 8. 마무리

- Spring WebFlux는 **현대적 고동시성 서비스**를 위한 강력한 대안 웹 스택이다.
- 다만 “무조건 더 빠르고 좋다”기보다는,
  - 트래픽 특성, 팀 역량, 연동 시스템 구조를 고려해
  - **MVC와 WebFlux 중 어떤 것이 ‘지금의 나에게’ 더 맞는지**를 판단하는 것이 중요하다.
- 학습 단계에서는:
  - 작은 WebFlux 프로젝트를 직접 만들어보고,
  - `Mono`/`Flux`, 라우터 함수, WebClient, 스케줄러, 예외 처리, 컨텍스트 등을
  - 하나씩 실험해 보며 **리액티브 사고방식에 익숙해지는 것**이 좋은 출발점이 된다.

