# 리액터 컨텍스트(Reactor Context) 핵심 정리

## 0. Executive Summary

- Reactor의 **컨텍스트(Context)** 는 Spring WebFlux 같은 **비동기·병렬 환경에서의 데이터 공유**를 위해 설계된 기능이다.
- 스케줄러 사용으로 스레드가 계속 바뀌는 환경에서는 `ThreadLocal` 로 데이터를 안정적으로 공유할 수 없기 때문에,
  - 컨텍스트는 **“스레드가 아닌 리액티브 시퀀스 자체”** 에 데이터를 바인딩하는 대안 역할을 한다.
- 컨텍스트의 가장 중요한 특징은 **불변성(Immutability)** 이다.
  - 한 번 생성된 컨텍스트는 변경되지 않고,
  - 값을 추가/수정하면 **새로운 컨텍스트 인스턴스**가 만들어져 반환된다.
- `contextWrite()` 를 통해 데이터를 추가하며,
  - 컨텍스트는 **구독자(Subscriber)에서 생산자(Publisher) 방향**, 즉 **아래→위 (downstream→upstream)** 로 전파된다.
  - 여러 `contextWrite()` 를 체이닝할 경우, **가장 아래쪽(마지막)에 선언된 컨텍스트가 최종적으로 우선 적용**된다.

---

## 1. 리액터 컨텍스트의 정의와 목적

- 리액터 컨텍스트는 **리액티브 스트림 전체 워크플로우에 걸쳐 데이터를 공유**할 수 있도록 도와주는 기능이다.
- 목적:
  - **스레드에 의존하지 않고** 비동기 환경에서 데이터를 안정적으로 전파.
  - `ThreadLocal` 이 더 이상 유효하지 않은 환경에서의 **대체 수단** 제공.

### 1.1 ThreadLocal의 한계와 컨텍스트의 필요성

- `ThreadLocal` 문제:
  - 단일 스레드 내에서는 편리하지만,
  - Reactor에서 스케줄러를 사용하면 하나의 작업이 **여러 스레드에 걸쳐 실행**될 수 있다.
  - 이 경우, `ThreadLocal` 에 저장된 값은 다른 스레드로 **전달되지 않으므로** 신뢰할 수 없다.
- 리액터 컨텍스트의 해결 방식:
  - 데이터가 **“스레드”가 아니라 “리액티브 시퀀스”** 에 붙어 이동한다.
  - 스레드가 전환되더라도 같은 워크플로우 안에서는 **항상 같은 컨텍스트 데이터**에 접근 가능하다.

---

## 2. 핵심 특징

### 2.1 불변성 (Immutability)

- 컨텍스트는 **불변 객체**로 설계되어 있다.
  - 한 번 생성되면 내부 값이 변경되지 않는다.
  - 값을 추가/변경할 때는 기존 컨텍스트를 수정하는 대신, **새 컨텍스트를 생성**해서 반환한다.
- 불변성의 이유:
  1. **데이터 안전성**
     - DTO에서 setter를 없애는 것과 비슷하게, 한 번 정해진 값이 임의로 바뀌지 않도록 보장한다.
     - 데이터가 여러 연산자를 거치면서도 **의도치 않게 변경되지 않는다**.
  2. **동시성 이슈 방지**
     - 여러 스레드가 동시에 컨텍스트를 참조하더라도,
       - 누군가가 값을 바꾸는 상황 자체가 발생하지 않기 때문에
       - “언제 값이 바뀌었는지” 같은 동시성 버그를 원천 차단한다.

### 2.2 리액터 연산자와의 통합

- 컨텍스트는 `map`, `flatMap` 등의 **모든 리액터 연산자와 통합**되어 동작한다.
- 리액티브 체인의 어느 위치에서든 컨텍스트를 읽고 활용할 수 있다.
  - 예: 인증 정보, 트레이싱 ID, 로깅 관련 메타데이터 등을 연산자 체인 전반에서 공유.

### 2.3 지연된 컨텍스트 설정

- 비동기 데이터 흐름 **중간 지점**에서 컨텍스트 값을 추가/변경하는 것도 가능하다.
  - 특정 연산이 수행되기 직전에 필요한 정보를 컨텍스트에 주입.
  - 예: 어떤 서비스 호출 이후에만 알게 되는 값을 이후 단계 컨텍스트에 추가.

---

## 3. 사용 방법 및 동작 원리

### 3.1 `contextWrite()` – 컨텍스트 추가/변경

- `Mono` 또는 `Flux` 에 체이닝하여 사용한다.
- 동작 방식:
  - 기존 컨텍스트를 **직접 변경하지 않고**, 새로운 컨텍스트를 만들어 반환.
  - 즉, 항상 **새 컨텍스트 객체**가 만들어져 체인에 연결된다.

#### 3.1.1 컨텍스트 생성 및 추가

- `Context.of("key", "value")`
  - 새로운 컨텍스트 객체를 생성한다.
  - 기존 컨텍스트가 있었다면 **덮어쓴다**.

- `context.put("key", "value")`
  - 기존 컨텍스트를 기반으로, 해당 키에 대한 값을 추가/수정한 **새 컨텍스트**를 생성한다.
  - 체인 내부에서 `contextWrite` 에 람다로 넘겨 사용.

### 3.2 컨텍스트 데이터 접근 – `deferContextual`

- 리액티브 체인 내부에서 컨텍스트 값을 읽기 위해 `Mono.deferContextual()` 또는 `Flux.deferContextual()` 을 사용한다.
- 이 메서드는 `ContextView` 를 인자로 제공하고,
  - `get()`, `getOrDefault()` 등을 통해 값에 접근할 수 있다.

#### 3.2.1 개념적 예제 구조

- 개념 형태:
  - `Mono.just("message")`
  - `.flatMap(msg -> Mono.deferContextual(ctxView -> {`
  - &nbsp;&nbsp;&nbsp;&nbsp;`String v1 = ctxView.getOrDefault("key", "default");`
  - &nbsp;&nbsp;&nbsp;&nbsp;`String v2 = ctxView.getOrDefault("otherKey", "default");`
  - &nbsp;&nbsp;&nbsp;&nbsp;`return Mono.just(msg + " with " + v1 + " and " + v2);`
  - `}))`
  - `// ... contextWrite(...) 체인 ...`

- 포인트:
  - `deferContextual` 은 **실행 시점**의 컨텍스트를 읽는다.
  - 컨텍스트는 **체인 아래쪽의 `contextWrite()` 설정**에 따라 결정된다.

### 3.3 전파 방향 및 적용 순서

- 컨텍스트 전파의 가장 중요한 특징:
  - **상향식 전파 (Bottom-up / downstream → upstream)**.
  - 컨텍스트는 **구독 시점(subscribe)** 에서 시작하여, 체인의 아래에서 위로 올라간다.

- 결과적으로:
  - 여러 `contextWrite()` 를 체인으로 연결하면,
  - **가장 아래쪽(마지막)에 위치한 `contextWrite()` 가 최종 컨텍스트를 결정**한다.

#### 3.3.1 체이닝 시 주의사항

- 코드 상단(위쪽)에 있는 `contextWrite()` 호출이,
  - 하단(아래쪽)에 있는 `contextWrite()` 에 의해 **덮어씌워질 수 있다**.
- 따라서:
  - “어떤 값을 최종으로 사용하게 될지” 를 설계할 때
  - **`contextWrite()` 의 선언 순서**에 각별히 주의해야 한다.

---

## 4. 결론

- 리액터 컨텍스트는 `ThreadLocal` 과 비슷하게 **데이터 공유**를 목표로 하지만,
  - 스레드가 자주 바뀌는 리액티브 환경에 맞춰 설계된 **보다 안전하고 일관된 메커니즘**이다.
- 불변성을 통해:
  - 데이터 무결성과 동시성 안전을 확보하고,
  - 여러 연산자와 스레드에 걸쳐도 **예측 가능한 방식으로 값이 전파**된다.
- 컨텍스트의
  - **상향식 전파 방향**과
  - **체인의 가장 아래쪽 `contextWrite()` 가 우선 적용된다**는 규칙을 이해하면,
  - 복잡한 비동기 워크플로우에서도 인증 정보, 트레이싱 ID, 요청 컨텍스트 등 다양한 데이터를
    **안전하게 전달·공유**할 수 있다.

